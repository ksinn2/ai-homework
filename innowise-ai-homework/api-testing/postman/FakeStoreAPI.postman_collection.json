{
  "info": {
    "name": "Fake Store API Tests",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "_exporter_id": "12345678"
  },
  "item": [
    {
      "name": "Get All Products",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// Verify server response code (expected 200)",
              "pm.test(\"Status code is 200\", function() {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// Parse the response JSON",
              "const responseData = pm.response.json();",
              "",
              "// Check that response is an array",
              "pm.test(\"Response is an array of products\", function() {",
              "    pm.expect(Array.isArray(responseData)).to.be.true;",
              "    pm.expect(responseData.length).to.be.greaterThan(0);",
              "});",
              "",
              "// Initialize array to track defects",
              "let productsWithDefects = [];",
              "",
              "// Validate each product",
              "responseData.forEach(product => {",
              "    // Validate title (must not be empty)",
              "    const hasValidTitle = product.title && product.title.trim() !== '';",
              "    if (!hasValidTitle) {",
              "        productsWithDefects.push({",
              "            id: product.id,",
              "            defect: 'Empty or missing title',",
              "            product: product",
              "        });",
              "    }",
              "    ",
              "    // Validate price (must not be negative)",
              "    const hasValidPrice = product.price !== undefined && product.price >= 0;",
              "    if (!hasValidPrice) {",
              "        productsWithDefects.push({",
              "            id: product.id,",
              "            defect: 'Negative or missing price',",
              "            product: product",
              "        });",
              "    }",
              "    ",
              "    // Validate rating.rate (must not exceed 5)",
              "    const hasValidRating = ",
              "        product.rating && ",
              "        product.rating.rate !== undefined && ",
              "        product.rating.rate <= 5;",
              "    if (!hasValidRating) {",
              "        productsWithDefects.push({",
              "            id: product.id,",
              "            defect: 'Rating exceeds 5 or is missing',",
              "            product: product",
              "        });",
              "    }",
              "});",
              "",
              "// Test for valid title in all products",
              "pm.test(\"All products have non-empty titles\", function() {",
              "    responseData.forEach(product => {",
              "        pm.expect(product.title).to.exist.and.to.not.be.empty;",
              "    });",
              "});",
              "",
              "// Test for valid price in all products",
              "pm.test(\"All products have non-negative prices\", function() {",
              "    responseData.forEach(product => {",
              "        pm.expect(product.price).to.exist.and.to.be.at.least(0);",
              "    });",
              "});",
              "",
              "// Test for valid rating in all products",
              "pm.test(\"All products have ratings not exceeding 5\", function() {",
              "    responseData.forEach(product => {",
              "        pm.expect(product.rating).to.exist;",
              "        pm.expect(product.rating.rate).to.exist.and.to.be.at.most(5);",
              "    });",
              "});",
              "",
              "// Output any defects found",
              "if (productsWithDefects.length > 0) {",
              "    console.log('Products with defects:', JSON.stringify(productsWithDefects, null, 2));",
              "    ",
              "    // Group defects by type for summary",
              "    const defectTypes = {};",
              "    productsWithDefects.forEach(defect => {",
              "        if (!defectTypes[defect.defect]) {",
              "            defectTypes[defect.defect] = [];",
              "        }",
              "        defectTypes[defect.defect].push(defect.id);",
              "    });",
              "    ",
              "    // Print defect summary",
              "    console.log('\\nDefect Summary:');",
              "    console.log('==============');",
              "    console.log(`Total products with defects: ${productsWithDefects.length}`);",
              "    ",
              "    for (const [type, productIds] of Object.entries(defectTypes)) {",
              "        console.log(`\\n${type}: ${productIds.length} product(s)`);",
              "        console.log(`Products with this defect: ${productIds.join(', ')}`);",
              "    }",
              "    ",
              "    // Create environment variable to store the defects",
              "    pm.environment.set('productsWithDefects', JSON.stringify(productsWithDefects));",
              "} else {",
              "    console.log('No defects found in products.');",
              "    pm.environment.set('productsWithDefects', '[]');",
              "}",
              "",
              "// If defects were found, save the first defective product ID for single product test",
              "if (productsWithDefects.length > 0) {",
              "    pm.environment.set('productId', productsWithDefects[0].id.toString());",
              "} else if (responseData.length > 0) {",
              "    // Otherwise just use the first product",
              "    pm.environment.set('productId', responseData[0].id.toString());",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{baseUrl}}/products",
          "host": [
            "{{baseUrl}}"
          ],
          "path": [
            "products"
          ]
        }
      },
      "response": []
    },
    {
      "name": "Get Single Product",
      "event": [
        {
          "listen": "test",
          "script": {
            "exec": [
              "// Verify server response code (expected 200)",
              "pm.test(\"Status code is 200\", function() {",
              "    pm.response.to.have.status(200);",
              "});",
              "",
              "// Parse the response JSON",
              "const product = pm.response.json();",
              "",
              "// Initialize array to track defects",
              "let defects = [];",
              "",
              "// Validate title (must not be empty)",
              "pm.test(\"Product has non-empty title\", function() {",
              "    const hasValidTitle = product.title && product.title.trim() !== '';",
              "    pm.expect(hasValidTitle).to.be.true;",
              "    ",
              "    if (!hasValidTitle) {",
              "        defects.push({",
              "            attribute: 'title',",
              "            defect: 'Empty or missing title'",
              "        });",
              "    }",
              "});",
              "",
              "// Validate price (must not be negative)",
              "pm.test(\"Product has non-negative price\", function() {",
              "    const hasValidPrice = product.price !== undefined && product.price >= 0;",
              "    pm.expect(hasValidPrice).to.be.true;",
              "    ",
              "    if (!hasValidPrice) {",
              "        defects.push({",
              "            attribute: 'price',",
              "            defect: 'Negative or missing price'",
              "        });",
              "    }",
              "});",
              "",
              "// Validate rating.rate (must not exceed 5)",
              "pm.test(\"Product rating does not exceed 5\", function() {",
              "    const hasValidRating = ",
              "        product.rating && ",
              "        product.rating.rate !== undefined && ",
              "        product.rating.rate <= 5;",
              "    pm.expect(hasValidRating).to.be.true;",
              "    ",
              "    if (!hasValidRating) {",
              "        defects.push({",
              "            attribute: 'rating.rate',",
              "            defect: 'Rating exceeds 5 or is missing'",
              "        });",
              "    }",
              "});",
              "",
              "// Output any defects found",
              "if (defects.length > 0) {",
              "    console.log(`Product ID ${product.id} has the following defects:`, JSON.stringify(defects, null, 2));",
              "} else {",
              "    console.log(`Product ID ${product.id} passed all validation checks.`);",
              "}"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{baseUrl}}/products/{{productId}}",
          "host": [
            "{{baseUrl}}"
          ],
          "path": [
            "products",
            "{{productId}}"
          ]
        }
      },
      "response": []
    },
    {
      "name": "Test Mock Data",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "exec": [
              "// Define mock data with intentional defects",
              "const mockData = [",
              "  {",
              "    id: 1,",
              "    title: \"Product 1\",",
              "    price: 10.99,",
              "    rating: { rate: 4.5, count: 100 }",
              "  },",
              "  {",
              "    id: 2,",
              "    title: \"\",  // Empty title - defect",
              "    price: 29.99,",
              "    rating: { rate: 3.8, count: 50 }",
              "  },",
              "  {",
              "    id: 3,",
              "    title: \"Product 3\",",
              "    price: -5.99,  // Negative price - defect",
              "    rating: { rate: 4.2, count: 200 }",
              "  },",
              "  {",
              "    id: 4,",
              "    title: \"Product 4\",",
              "    price: 15.99,",
              "    rating: { rate: 5.2, count: 75 }  // Rating > 5 - defect",
              "  },",
              "  {",
              "    id: 5,",
              "    title: \"Product 5\",",
              "    price: 25.50,",
              "    rating: { count: 150 }  // Missing rate - defect",
              "  }",
              "];",
              "",
              "// Store mock data in a variable that can be accessed in the test script",
              "pm.variables.set('mockData', JSON.stringify(mockData));"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "exec": [
              "// Load mock data from variable",
              "const responseData = JSON.parse(pm.variables.get('mockData'));",
              "",
              "// Initialize array to track defects",
              "let productsWithDefects = [];",
              "",
              "// Validate each product",
              "responseData.forEach(product => {",
              "    // Validate title (must not be empty)",
              "    const hasValidTitle = product.title && product.title.trim() !== '';",
              "    if (!hasValidTitle) {",
              "        productsWithDefects.push({",
              "            id: product.id,",
              "            defect: 'Empty or missing title',",
              "            product: product",
              "        });",
              "    }",
              "    ",
              "    // Validate price (must not be negative)",
              "    const hasValidPrice = product.price !== undefined && product.price >= 0;",
              "    if (!hasValidPrice) {",
              "        productsWithDefects.push({",
              "            id: product.id,",
              "            defect: 'Negative or missing price',",
              "            product: product",
              "        });",
              "    }",
              "    ",
              "    // Validate rating.rate (must not exceed 5)",
              "    const hasValidRating = ",
              "        product.rating && ",
              "        product.rating.rate !== undefined && ",
              "        product.rating.rate <= 5;",
              "    if (!hasValidRating) {",
              "        productsWithDefects.push({",
              "            id: product.id,",
              "            defect: 'Rating exceeds 5 or is missing',",
              "            product: product",
              "        });",
              "    }",
              "});",
              "",
              "// Test for valid title in all products",
              "pm.test(\"All products have non-empty titles\", function() {",
              "    // This test is expected to fail with mock data",
              "    responseData.forEach(product => {",
              "        pm.expect(product.title).to.exist.and.to.not.be.empty;",
              "    });",
              "});",
              "",
              "// Test for valid price in all products",
              "pm.test(\"All products have non-negative prices\", function() {",
              "    // This test is expected to fail with mock data",
              "    responseData.forEach(product => {",
              "        pm.expect(product.price).to.exist.and.to.be.at.least(0);",
              "    });",
              "});",
              "",
              "// Test for valid rating in all products",
              "pm.test(\"All products have ratings not exceeding 5\", function() {",
              "    // This test is expected to fail with mock data",
              "    responseData.forEach(product => {",
              "        pm.expect(product.rating).to.exist;",
              "        pm.expect(product.rating.rate).to.exist.and.to.be.at.most(5);",
              "    });",
              "});",
              "",
              "// Output defects (expected in mock data)",
              "console.log('Mock data validation:');",
              "console.log('Products with defects:', JSON.stringify(productsWithDefects, null, 2));",
              "",
              "// Group defects by type for summary",
              "const defectTypes = {};",
              "productsWithDefects.forEach(defect => {",
              "    if (!defectTypes[defect.defect]) {",
              "        defectTypes[defect.defect] = [];",
              "    }",
              "    defectTypes[defect.defect].push(defect.id);",
              "});",
              "",
              "// Print defect summary",
              "console.log('\\nDefect Summary:');",
              "console.log('==============');",
              "console.log(`Total products with defects: ${productsWithDefects.length}`);",
              "",
              "for (const [type, productIds] of Object.entries(defectTypes)) {",
              "    console.log(`\\n${type}: ${productIds.length} product(s)`);",
              "    console.log(`Products with this defect: ${productIds.join(', ')}`);",
              "}",
              "",
              "// The mock data should have defects - this test verifies our validation works",
              "pm.test(\"Mock data contains expected defects\", function() {",
              "    pm.expect(productsWithDefects.length).to.be.greaterThan(0);",
              "});",
              "",
              "// Expecting specific defects in our mock data",
              "pm.test(\"Mock data contains empty title defect\", function() {",
              "    const emptyTitleDefect = productsWithDefects.find(defect => ",
              "        defect.defect === 'Empty or missing title' && defect.id === 2);",
              "    pm.expect(emptyTitleDefect).to.exist;",
              "});",
              "",
              "pm.test(\"Mock data contains negative price defect\", function() {",
              "    const negativePriceDefect = productsWithDefects.find(defect => ",
              "        defect.defect === 'Negative or missing price' && defect.id === 3);",
              "    pm.expect(negativePriceDefect).to.exist;",
              "});",
              "",
              "pm.test(\"Mock data contains rating exceeds 5 defect\", function() {",
              "    const ratingExceedsDefect = productsWithDefects.find(defect => ",
              "        defect.defect === 'Rating exceeds 5 or is missing' && defect.id === 4);",
              "    pm.expect(ratingExceedsDefect).to.exist;",
              "});",
              "",
              "pm.test(\"Mock data contains missing rating defect\", function() {",
              "    const missingRatingDefect = productsWithDefects.find(defect => ",
              "        defect.defect === 'Rating exceeds 5 or is missing' && defect.id === 5);",
              "    pm.expect(missingRatingDefect).to.exist;",
              "});"
            ],
            "type": "text/javascript"
          }
        }
      ],
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{baseUrl}}/products/1",
          "host": [
            "{{baseUrl}}"
          ],
          "path": [
            "products",
            "1"
          ]
        },
        "description": "This request uses mock data with deliberate defects to test the validation logic. The tests are expected to fail, demonstrating that our validation can detect the defects."
      },
      "response": []
    }
  ]
} 